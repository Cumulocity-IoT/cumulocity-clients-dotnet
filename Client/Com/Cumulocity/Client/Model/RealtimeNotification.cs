///
/// RealtimeNotification.cs
/// CumulocityCoreLibrary
///
/// Copyright (c) 2014-2022 Software AG, Darmstadt, Germany and/or Software AG USA Inc., Reston, VA, USA, and/or its subsidiaries and/or its affiliates and/or their licensors.
/// Use, reproduction, transfer, publication or disclosure is prohibited except as specifically provided for in your License Agreement with Software AG.
///

using System.Collections.Generic;
using Com.Cumulocity.Client.Converter;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.Runtime.Serialization;

namespace Com.Cumulocity.Client.Model 
{
	public class RealtimeNotification 
	{
	
		/// <summary>
		/// Configuration parameters for the current connect message.
		/// </summary>
		[JsonPropertyName("advice")]
		public Advice? PAdvice { get; set; }
	
		/// <summary>
		/// The channel name as a URI.
		/// </summary>
		[JsonPropertyName("channel")]
		public Channel? PChannel { get; set; }
	
		/// <summary>
		/// Unique client ID generated by the server during handshake. Required for all other operations.
		/// </summary>
		[JsonPropertyName("clientId")]
		public string? ClientId { get; set; }
	
		/// <summary>
		/// Selected connection type.
		/// </summary>
		[JsonPropertyName("connectionType")]
		public string? ConnectionType { get; set; }
	
		/// <summary>
		/// List of notifications from the channel.
		/// </summary>
		[JsonPropertyName("data")]
		public Data? PData { get; set; }
	
		/// <summary>
		/// Operation failure reason (only present if the operation was not successful).
		/// </summary>
		[JsonPropertyName("error")]
		public string? Error { get; set; }
	
		/// <summary>
		/// Authentication object passed to handshake (only over WebSockets).
		/// </summary>
		[JsonPropertyName("ext")]
		public Ext? PExt { get; set; }
	
		/// <summary>
		/// ID of the message passed in a request. Required to match the response message.
		/// </summary>
		[JsonPropertyName("id")]
		public string? Id { get; set; }
	
		/// <summary>
		/// Minimum server-side Bayeux protocol version required by the client (in a request) or minimum client-side Bayeux protocol version required by the server (in a response).
		/// </summary>
		[JsonPropertyName("minimumVersion")]
		public string? MinimumVersion { get; set; }
	
		/// <summary>
		/// Name of the channel to subscribe to. Subscription channels are available for [Alarms](#tag/Alarm-notification-API), [Device control](#tag/Device-control-notification-API), [Events](#tag/Event-notification-API), [Inventory](#tag/Inventory-notification-API) and [Measurements](#tag/Measurement-notification-API).
		/// </summary>
		[JsonPropertyName("subscription")]
		public string? Subscription { get; set; }
	
		/// <summary>
		/// Indicates if the operation was successful.
		/// </summary>
		[JsonPropertyName("successful")]
		public bool? Successful { get; set; }
	
		/// <summary>
		/// Connection types supported by both client and server, that is, intersection between client and server options.
		/// </summary>
		[JsonPropertyName("supportedConnectionTypes")]
		public List<string>? SupportedConnectionTypes { get; set; }
	
		/// <summary>
		/// [Bayeux protocol](https://docs.cometd.org/current/reference/#_concepts_bayeux_protocol) version used by the client (in a request) or server (in a response).
		/// 
		/// </summary>
		[JsonPropertyName("version")]
		public string? Version { get; set; }
	
		public RealtimeNotification() 
		{
		}
	
		public RealtimeNotification(Channel channel)
		{
			this.PChannel = channel;
		}
	
		/// <summary>
		/// The channel name as a URI.
		/// [/meta/handshake, /meta/subscribe, /meta/unsubscribe, /meta/connect, /meta/disconnect]
		/// </summary>
		[JsonConverter(typeof(EnumConverterFactory))]
		public enum Channel 
		{
			[EnumMember(Value = "/meta/handshake")]
			METAHANDSHAKE,
			[EnumMember(Value = "/meta/subscribe")]
			METASUBSCRIBE,
			[EnumMember(Value = "/meta/unsubscribe")]
			METAUNSUBSCRIBE,
			[EnumMember(Value = "/meta/connect")]
			METACONNECT,
			[EnumMember(Value = "/meta/disconnect")]
			METADISCONNECT
		}
	
		/// <summary>
		/// Configuration parameters for the current connect message.
		/// </summary>
		public class Advice 
		{
		
			/// <summary>
			/// Period (milliseconds) after which the server will close the session, if it doesn't received the next connect message from the client. Overrides server default settings for current request-response conversation.
			/// </summary>
			[JsonPropertyName("interval")]
			public int? Interval { get; set; }
		
			/// <summary>
			/// Interval (milliseconds) between the sending of the connect message and the response from the server. Overrides server default settings for the current request-response conversation.
			/// </summary>
			[JsonPropertyName("timeout")]
			public int? Timeout { get; set; }
		
			public override string ToString()
			{
				var jsonOptions = new JsonSerializerOptions() 
				{ 
					WriteIndented = true,
					DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull
				};
				return JsonSerializer.Serialize(this, jsonOptions);
			}
		}
	
	
		/// <summary>
		/// List of notifications from the channel.
		/// </summary>
		public class Data 
		{
		
			public override string ToString()
			{
				var jsonOptions = new JsonSerializerOptions() 
				{ 
					WriteIndented = true,
					DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull
				};
				return JsonSerializer.Serialize(this, jsonOptions);
			}
		}
	
		/// <summary>
		/// Authentication object passed to handshake (only over WebSockets).
		/// </summary>
		public class Ext 
		{
		
			[JsonPropertyName("com.cumulocity.authn")]
			public Comcumulocityauthn? PComcumulocityauthn { get; set; }
		
			/// <summary>
			/// The system of units to use.
			/// </summary>
			[JsonPropertyName("systemOfUnits")]
			public SystemOfUnits? PSystemOfUnits { get; set; }
		
			/// <summary>
			/// The system of units to use.
			/// [imperial, metric]
			/// </summary>
			[JsonConverter(typeof(EnumConverterFactory))]
			public enum SystemOfUnits 
			{
				[EnumMember(Value = "imperial")]
				IMPERIAL,
				[EnumMember(Value = "metric")]
				METRIC
			}
		
			public class Comcumulocityauthn 
			{
			
				/// <summary>
				/// Base64 encoded credentials.
				/// </summary>
				[JsonPropertyName("token")]
				public string? Token { get; set; }
			
				/// <summary>
				/// Optional two factor authentication token.
				/// </summary>
				[JsonPropertyName("tfa")]
				public string? Tfa { get; set; }
			
				/// <summary>
				/// Required for OAuth authentication.
				/// </summary>
				[JsonPropertyName("xsrfToken")]
				public string? XsrfToken { get; set; }
			
				public override string ToString()
				{
					var jsonOptions = new JsonSerializerOptions() 
					{ 
						WriteIndented = true,
						DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull
					};
					return JsonSerializer.Serialize(this, jsonOptions);
				}
			}
		
		
			public override string ToString()
			{
				var jsonOptions = new JsonSerializerOptions() 
				{ 
					WriteIndented = true,
					DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull
				};
				return JsonSerializer.Serialize(this, jsonOptions);
			}
		}
	
		public override string ToString()
		{
			var jsonOptions = new JsonSerializerOptions() 
			{ 
				WriteIndented = true,
				DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull
			};
			return JsonSerializer.Serialize(this, jsonOptions);
		}
	}
}
